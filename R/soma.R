#' @import reportr
#' @importFrom graphics plot
#' @importFrom stats runif
NULL

#' Options for the available SOMA variants
#' 
#' These functions generate option lists (and provide defaults) for the SOMA
#' algorithm variants available in the package, which control how the algorithm
#' will proceed and when it will terminate.
#' 
#' @param pathLength The distance towards the leader that individuals may
#'   migrate. A value of 1 corresponds to the leader's position itself, and
#'   values greater than one (recommended) allow for some overshoot.
#' @param stepLength The granularity at which potential steps are evaluated.
#'   It is recommended that the \code{pathLength} not be a whole multiple of
#'   this value.
#' @param perturbationChance The probability that individual parameters are
#'   changed on any given step.
#' @param minAbsoluteSep The smallest absolute difference between the maximum
#'   and minimum cost function values. If the difference falls below this
#'   minimum, the algorithm will terminate. The default is 0, meaning that this
#'   termination criterion will never be met.
#' @param minRelativeSep The smallest relative difference between the maximum
#'   and minimum cost function values. If the difference falls below this
#'   minimum, the algorithm will terminate.
#' @param nMigrations The maximum number of migrations to complete.
#' @param populationSize The number of individuals in the population. It is
#'   recommended that this be somewhat larger than the number of parameters
#'   being optimised over, and it should not be less than 2.
#' @return A list of class \code{"soma.options"}.
#' @author Jon Clayden <code@@clayden.org>
#' @aliases soma.options
#' @rdname soma.options
#' @export
all2one <- function (pathLength = 3, stepLength = 0.11, perturbationChance = 0.1, minAbsoluteSep = 0, minRelativeSep = 1e-3, nMigrations = 20L, populationSize = 10L)
{
    assert(populationSize >= 2L, "Population size must be at least 2")
    options <- list(strategy="all2one", pathLength=pathLength, stepLength=stepLength, perturbationChance=perturbationChance, minAbsoluteSep=minAbsoluteSep, minRelativeSep=minRelativeSep, nMigrations=nMigrations, populationSize=populationSize)
    class(options) <- "soma.options"
    return (options)
}

#' The Self-Organising Migrating Algorithm
#' 
#' The Self-Organising Migrating Algorithm is a general-purpose, stochastic
#' optimisation algorithm. The approach is similar to that of genetic
#' algorithms, although it is based on the idea of a series of ``migrations''
#' by a fixed set of individuals, rather than the development of successive
#' generations. It can be applied to any cost-minimisation problem with a
#' bounded parameter space, and is robust to local minima.
#' 
#' @param costFunction A cost function which takes a numeric vector of
#'   parameters as its first argument, and returns a numeric scalar
#'   representing the associated cost value.
#' @param bounds A list with elements \code{min} and \code{max}, each a numeric
#'   vector giving the upper and lower bounds for each parameter, respectively.
#' @param min,max Vectors of minimum and maximum bound values for each
#'   parameter to the \code{costFunction}.
#' @param options A list of options for the SOMA algorithm itself, usually
#'   generated by functions like \code{\link{all2one}}.
#' @param \dots Additional parameters to \code{costFunction} (for \code{soma})
#'   or the default plotting method (for \code{plot.soma}).
#' @param x An object of class \code{"soma"}.
#' @param y Ignored.
#' @return A list of class \code{"soma"}, containing the following elements.
#'   \describe{
#'     \item{leader}{The index of the ``leader'', the individual in the
#'       population with the lowest cost.}
#'     \item{population}{A matrix whose columns give the parameter values for
#'       each individual in the population at convergence.}
#'     \item{cost}{A vector giving the cost function values for each individual
#'       at convergence.}
#'     \item{history}{A vector giving the cost of the leader for each migration
#'       during the optimisation. This should be nonincreasing.}
#'     \item{migrations}{The number of migrations completed.}
#'     \item{evaluations}{The number of times the \code{costFunction} was
#'       evaluated.}
#'   }
#'   A \code{plot} method is available for this class, which shows the history
#'     of leader cost values during the optimisation.
#' @examples
#' # Rastrigin's function, which contains many local minima
#' rastrigin <- function (a) 20 + a[1]^2 + a[2]^2 - 10*(cos(2*pi*a[1])+cos(2*pi*a[2]))
#' 
#' # Find the global minimum over the range -5 to 5 in each parameter
#' x <- soma(rastrigin, list(min=c(-5,-5),max=c(5,5)))
#' 
#' # Find the location of the leader - should be near the true minimum of c(0,0)
#' print(x$population[,x$leader])
#' 
#' # Plot the cost history of the leaders
#' plot(x)
#' @references
#'   I. Zelinka (2004). SOMA - self-organizing migrating algorithm. In G.C.
#'   Onwubolu & B.V. Babu, eds, New optimization techniques in engineering.
#'   Volume 141 of ``Studies in Fuzziness and Soft Computing'', pp. 167-217.
#'   Springer.
#' @author R implementation by Jon Clayden <code@@clayden.org>.
#' @seealso \code{\link{soma.options}} for setting options. \code{\link{optim}} implements other general-purpose optimisation
#'   methods.
#' @export
soma <- function (costFunction, bounds, options = list(), ...)
{
    # Check bounds and options
    if (!inherits(bounds, "soma.bounds"))
        bounds <- do.call(soma::bounds, bounds)
    if (!inherits(options, "soma.options"))
        options <- do.call(soma::all2one, options)
    
    nParams <- length(bounds$min)
    nParamsTotal <- nParams * options$populationSize
    steps <- seq(0, options$pathLength, options$stepLength)
    nSteps <- length(steps)
    steps <- rep(steps, each=nParamsTotal)
    
    # Create the population
    population <- matrix(runif(nParamsTotal), nrow=nParams, ncol=options$populationSize)
    population <- population * (bounds$max-bounds$min) + bounds$min
    
    # Calculate initial costs
    evaluationCount <- 0
    costFunctionWrapper <- function(x) { evaluationCount <<- evaluationCount + 1; costFunction(x, ...) }
    costFunctionValues <- apply(population, 2, costFunctionWrapper)
    
    migrationCount <- 0
    leaderCostHistory <- numeric(0)
    
    report(OL$Info, "Starting SOMA optimisation")
    
    repeat
    {
        # Find the current leader
        leaderIndex <- which.min(costFunctionValues)
        leaderValue <- costFunctionValues[leaderIndex]
        separationOfExtremes <- max(costFunctionValues) - leaderValue
        sumOfExtremes <- max(costFunctionValues) + leaderValue
        
        # Check termination criteria
        if (migrationCount == options$nMigrations)
        {
            report(OL$Info, "Migration limit (", options$nMigrations, ") reached - stopping")
            break
        }
        if (separationOfExtremes < options$minAbsoluteSep)
        {
            report(OL$Info, "Absolute cost separation (", signif(separationOfExtremes,3), ") is below threshold (", signif(options$minAbsoluteSep,3), ") - stopping")
            break
        }
        # isTRUE() needed here in case extremes are infinite: Inf/Inf => NaN
        if (isTRUE(abs(separationOfExtremes/sumOfExtremes) < options$minRelativeSep))
        {
            report(OL$Info, "Relative cost separation (", signif(separationOfExtremes/sumOfExtremes,3), ") is below threshold (", signif(options$minRelativeSep,3), ") - stopping")
            break
        }
        
        leaderCostHistory <- c(leaderCostHistory, leaderValue)
        
        # Find the migration direction for each individual
        directionsFromLeader <- apply(population, 2, "-", population[,leaderIndex])
        
        # Establish which parameters will be changed
        toPerturb <- runif(nParamsTotal) < options$perturbationChance
        
        # Second line here has a minus because directions are away from leader
        populationSteps <- array(rep(population,nSteps), dim=c(nParams,options$populationSize,nSteps))
        populationSteps <- populationSteps - steps * rep(directionsFromLeader * toPerturb, nSteps)
        
        # Replace out-of-bounds parameters with random valid values
        outOfBounds <- which(populationSteps < bounds$min | populationSteps > bounds$max)
        randomSteps <- array(runif(nParamsTotal*nSteps), dim=c(nParams,options$populationSize,nSteps))
        randomSteps <- randomSteps * (bounds$max-bounds$min) + bounds$min
        populationSteps[outOfBounds] <- randomSteps[outOfBounds]
        
        # Values over potential locations
        costFunctionValues <- apply(populationSteps, 2:3, costFunctionWrapper)
        individualBestLocs <- apply(costFunctionValues, 1, which.min)
        
        # Migrate each individual to its best new location, and update costs
        indexingMatrix <- cbind(seq_len(options$populationSize), individualBestLocs)
        population <- t(apply(populationSteps, 1, "[", indexingMatrix))
        costFunctionValues <- costFunctionValues[indexingMatrix]
        
        migrationCount <- migrationCount + 1
        if (migrationCount %% 10 == 0)
            report(OL$Verbose, "Completed ", migrationCount, " migrations")
    }
    
    report(OL$Info, "Leader is #", leaderIndex, ", with cost ", signif(costFunctionValues[leaderIndex],3))
    
    returnValue <- list(leader=leaderIndex, population=population, cost=costFunctionValues, history=leaderCostHistory, migrations=migrationCount, evaluations=evaluationCount)
    class(returnValue) <- "soma"
    
    return (returnValue)
}

#' @rdname soma
#' @export
bounds <- function (min, max)
{
    min <- as.numeric(min)
    max <- as.numeric(max)
    assert(length(min) == length(max), "Bounds are not of equal length")
    assert(all(is.finite(min)) && all(is.finite(max)), "Bounds must be finite")
    assert(all(min <= max), "At least one minimum is greater than the equivalent maximum", level=OL$Warning)
    assert(all(min != max), "At least one minimum and maximum bound are equal - consider making these fixed arguments to the cost function", level=OL$Warning)
    return (structure(list(min=min, max=max), class="soma.bounds"))
}

#' @rdname soma
#' @export
plot.soma <- function (x, y = NULL, ...)
{
    plot(seq_along(x$history), x$history, xlab="Migration number", ylab="Leader cost value", type="b", ...)
}
